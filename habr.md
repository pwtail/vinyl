Асинхронный django: status update

Всем привет. Некоторое время назад я писал про альтернативные 
возможности добавить в django асинхронность, помимо официального подхода 
(DEP-09). Хочу сказать, у меня получилось оформить свои идеи в нечто цельное, что 
я назвал [*vinyl project*](https://github.com/pwtail/vinyl). 
Описание проекта можно прочитать на гитхабе, здесь же я хочу рассказать об 
используемом подходе и остановиться на интересных моментах.

демо

Проект позволяет использовать django для написания нативно асинхронного кода,
соответственно, он использует асинхронный драйвер базы данных (я использовал 
[psycopg3](https://www.psycopg.org/psycopg3/)).

Проект родился после нескольких предыдущих попыток, когда я узнал, что 
django очень неплохо расширяем. Например, он поддерживает использование 
нескольких баз данных одновременно, притом что модели одни и те же. 
Соответственно, ничего не мешает считать использование асинхронного драйвера 
как другую (логически) базу данных, чем я и воспользовался.

В результате, получилось поместить всю асинхронную функциональность внутрь 
менеджера моделей. Не понадобилось делать форка django или каких-то его 
сущностей. Использовать это можно так:

```python
class Artifact(models.Model):
    ...
    vinyl = VinylManager()
```

Как делать запросы? Используя менеджер `vinyl`: `Artifact.vinyl.all()`. 
Вообще, кверисеты в django ленивые, поэтому большая часть функциональности 
заработала сама. Переопределить потребовалось не ленивые методы вроде `.get()
`, `.count()` и `aggregate`. Но с этим не возникло проблем.

Теперь другая интересная особенность: *vinyl* поддерживает одновременно 
синхронный и асинхронный режим. Это зависит от флага, который можно 
установить динамически:

`from vinyl import set_async; set_async(False)`

Данная фича является уникальной среди ORM.

Как же это делается? Самый простой способ писать такой универсальный код - 
использовать генераторы, которые бы останавливались на потенциально 
асинхронных операциях. Но это не всегда бесплатно с точки зрения 
производительности, к тому же, есть ограничения на их использование в 
асинхронном контекте (но не буду на этом останавливаться). Без генераторов 
бывает трудно обойтись, если код напрямую портируется из синхронной версии. 
Код же `vinyl` писался с нуля, там где это было нужно.

Тем не менее, код `vinyl` является универсальным, то есть одна и та же 
функция вернёт корутину или обычное значение, в зависимости от флага 
`IS_ASYNC`. Именно поэтому Вы не найдёте в коде функций с аннотацией `async`.

Вот пример такой универсальной функции:

```python
from vinyl.futures import later

def myfunc():
    result = maybe_async_func()
    
    @later
    def myfunc(result=result):
        return ...

    return myfunc()

```

В синхронном случае декоратор `later` не делает ничего, в асинхронном случае 
- выполняет корутину `result`.

В результате, `vinyl`, в sync-режиме, позволяет обычные синхронные вызовы и 
в этом очень похож на django. Это несомненное благо для документации и 
тестирование, и в будущем может избавить фреймворк от каких-нибудь 
сумасшедших фич (которые будет трудно поддержать для синхронного и 
асинхронного случая одновременно).

Нужно сказать, что и без синхронной версии *vinyl* предназначен для 
использования в django проектах, которые и так могут использовать django для 
синхронного режима. Это значит, что такие проекты могут иметь WSGI и ASGI 
эндпоинты, использующие одно окружение и базу (насколько такое 
распространено сейчас, и насколько удобно?)


К сожалению (на мой взгляд, нет), в такой универсальном режиме сложно 
поддержать весь API django целиком. Ну, то есть, можно, но код будет 
выглядеть не лучшим образом, придётся использовать генераторы и прочее. 
Поэтому кое-где API *vinyl* более минималистичный, и не все фичи поддерживаются.

Например, я заменил `obj.save()` на более явные `.insert()` и `.update()`. В 
целом, что касается CRUD операций, API точно изменится.

Ленивые атрибуты тоже были урезаны. *vinyl* не позволяет делать запросы к базе 
под 
капотом, если данные не были загружены заранее, например, с помощью 
`prefetch_related`. Для операций на чтение несложно обеспечить другой 
API, например, `obj.fetch('related_obj')`, для операций на запись - использовать
вышеуказанные CRUD операции. Это избавляет от необходимости какого бы то ни 
было переопределения полей django можелей, а также от сложных цепочек 
сохранения связанных объектов. В результате получаем более явный API с 
более прозрачными запросами к базе.

**Резюме**

На мой взгляд, без асинхронной функциональности django обречено на вымирание.
Описанный фреймворк - первая попытка использовать django как библиотеку и 
как зависимость для другого фреймворка.

Несмотря на некоторые урезанные возможности, *vinyl* всё равно предоставляет 
более широкие возможности, чем большинство асинхронных фреймворков. А 
наличие синхронной версии гарантирует его гармоничное развитие и возможность 
писать сервисы с синхронными и асинхронными эндпоинтами одновременно.

Что касается дальнейшего развития фреймворка: я, конечно, в курсе, что есть 
большое 
количество средних и крупных проектов на django, которые страдают от 
отсутствия в django нативной асинхронности. Я планирую развивать фреймворк 
внутри таких проектов, в боевых условиях. Хочу заметить, что *vinyl* - это 
независимый от django код, который можно менять и адаптировать как угодно.