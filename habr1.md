Асинхронный django: status update

Всем привет. Некоторое время назад я писал про альтернативные 
возможности, как можно добавить в django асинхронность, кроме официального 
подхода 
(DEP-09). Хочу сказать, у меня получилось оформить свои идеи в нечто цельное, что 
я назвал [*vinyl project*](https://github.com/pwtail/vinyl). 
Описание проекта можно найти на гитхабе, здесь же я хочу рассказать об 
используемом подходе и остановиться на интересных моментах.

В отличие от официального подхода (DEP-09), проект имеет целью
поддержку нативной асинхронности для проектов с django.

Проект родился после нескольких предыдущих попыток, когда я узнал, что 
django, в действительности, очень неплохо расширяем. Например, он поддерживает 
использование 
нескольких баз данных одновременно, притом что модели одни и те же. 
Соответственно, ничего не мешает считать использование асинхронного драйвера 
как использование другой логической базы данных, чем я и воспользовался.

В результате, получилось поместить всю асинхронную функциональность внутрь 
менеджера моделей. Не понадобилось делать форк django или его частей. 

Вначале - небольшое демо того, что получилось. Для тестирования я 
использовал асинхронный драйвер [psycopg3](https://www.psycopg.org/psycopg3/)).

```python
from django.db import models
from vinyl.manager import VinylManager

class Entry(models.Model):
    x = models.IntegerField()
    
    vinyl = VinylManager()
```

`Entry` - обычная модель django. Можно пользоваться `Entry.objects` в полном 
соответствии с документацией django. Кроме этого, можно писать такой 
асинхронный код:

```python
from django.db.models import Avg

await Entry.vinyl.filter(x__gt=a, x__lt=b).aggregate(Avg('x'))
```

API для работы с кверисетами такой же как в django. Попробуем создать объект:

```python
obj = Entry.vinyl(x=1)
await obj.insert()
```

Как видим, здесь API несколько другой. Для создания объекта используется сам 
менеджер, а для сохранения объекта используется `.insert()` вместо `.save()`.
Сделаем апдейт:

```python
await obj.update(x=2)
```

Опять другой API. CRUD-операции с объектами действительно отличаются от тех, 
которые в django. *vinyl* делает выбор в пользу более явного API. Об этом 
подробнее ниже.

**Sync mode**

Пожалуй, самая странная фича *vinyl* - предоставление синхронного и 
асинхронного API одновременно. Регулируется это флагом, который можно 
установить динамически для данного потока:

```python
from vinyl import set_async; set_async(False)
```

После исполнения этой строчки при использовании `Entry.vinyl` будет 
использоваться синхронный ввод-вывод. То есть, мы сможем писать такой код:

```python
obj = Entry.vinyl.get(x=1)
obj.update(x=2)
```

История библиотек на питоне уже знает примеры такого подхода: например,
[sans-io](https://sans-io.readthedocs.io/). Его применение требует писать 
универсальный код, годный для использования как в синхронном, так и в 
асинхронном контексте. Поэтому вы почти не увидите в коде `async` и `await`, 
а увидите что-то наподобие такого:

```python
from vinyl.futures import later

def myfunc():
    result = maybe_async_func()
    
    @later
    def myfunc(result=result):
        print(f'The result was {result}')

    return myfunc()
```

`myfunc()` вернёт корутину или обычный питоновский объект (то есть, 
выполнится) в завсимости от установленного флага, отвечающего за асинхронность.

Надо сказать, эта странная фича - универсальный код - одна из немногих, у
которой нет реальной необходимости, и которая почти полностью является
капризом 
автора. Да, хорошо иметь возможность писать как синхронный, так и 
асинхронный код - но ведь никуда не девается сам django, у которого и так есть 
синхронный API. Это так, однако, на мой взгляд, наличие синхронной версии 
улучшает 
тестируемость и документирование, а также затрудняет добавление каких-то 
сумасшедших 
и ненужных фич.

**Упрощённый API на запись**

В коротком демо вначале мы узнали, что CRUD-операции с объектами отличаются 
от API django. Это и есть API на запись (в базу данных). Этот API 
действительно сделан более явным, и главное, более минималистичным.

Дело в том, что API django часто приводит к сложным цепочкам изменений в 
объектах, которые нужно учитывать в операциях на запись. В результате, для 
этого сложно писать нормальный универсальный (синхронно-асинхронный) код. 
Код действительно получается трудно читаемый, либо нужно прибегать к 
генераторам для несвойственных им целей.

Автор подумал, что неуклюжий код является свидетельством несовершенного API,
и что лучшим решением будет упростить API на запись. В 
результате, как правило, CRUD-операции приводят всего к одной 
операции на запись. Наследование моделей, конечно, немного добавляет проблем.

**Наследование моделей**

Я говорю про то, что называется "concrete model inheritance". Оно позволяет 
более компактно записать то, что используется `OneToOneField`, и при этом 
сократить цепочку атрибутов-связей в запросах. В общем, немного "избавиться от 
boilerplate". Но проблема в том, что, из-за того, что правила наследования 
достаточно свободные, при сохранении объекта (например, добавлении) объекта, 
нужно сохранять этих самых родителей в определённом порядке.

Не то, чтобы это очень сильно портило код, но я подумал, что небольшое 
ограничение правил наследования позволило бы сильно упростить вещи. Например,
разрешить только наследование только от одной "concrete" модели, причём 
чтобы родитель и был первичным ключом для ребёнка. Кстати, лично в своей 
практике я 
встречался именно с таким способом наследования. В таком случае, у всех 
родителей и детей одно и то же значение первичного ключа, и с этим гораздо 
проще работать. В частности, я думаю, нетрудно даже поддержать 
наследование в 
bulk-операциях, в том числе (чего в django нет).

Однако надо понимать, что ограничение наследования ломает совместимость с 
django, поэтому к этому нужно относиться осторожно (в остальном, *vinyl* не 
ломает совместимость нигде, да и это изменение только в проекте, пока 
наследование поддерживается как оно есть).

**Ленивые атрибуты**

Одна из типичных фич django API. `obj.related_obj` сделает запрос в базу или 
вернёт данные из кэша, в зависимости от сделанных предыдущих запросов. В 
асинхронном коде, конечно, если код потенциально содержит ввод-вывод 
(обращается к базе), он должен быть помечен с помощью `async` и `await`.

Но это не представляет особых трудностей для возможного API: вначале я думал 
сделать так, чтобы `obj.related_obj` возвращал объект, если он есть в кэше, 
и корутину, если его там нет. Во втором случае, для запроса объекта нужно 
было бы написать `await obj.related_obj`. Конечно, для этого бы 
потребовалось переопределить поля в моделях, отвечающие за связи.

Однако, потом нашлось более элегантное решение (и более 
минималистичное: переопределять поля не потребовалось). `prefetch_related`, к 
тому времени, уже поддерживался. Соответственно, если нужно было обратиться 
к атрибуту, который присутствовал в `prefetch_related` (или `select_related`), 
это можно 
было 
сделать без всяких проблем. Я подумал, что нужно разрешить только такой 
вариант использование атрибутов-связей. А для запросов в базу сделать 
какой-нибудь другой API. Например, `await obj.q.related_obj` (добавился 
атрибут `.q`). Как реализовать этот последний API? Очень просто: сначала 
делаем `prefetch_related`, потом возвращаем нужный атрибут.

Что мы получаем в итоге? API для чтения связанных объектов, простой в 
реализации. Ну, а API на запись, вроде `obj.collection.add(related_obj)`, 
как всегда, отсутствует. Что ж, возможно, он и не нужен, пользуйтесь 
вышеописанными CRUD-операциями.

**Резюме**

*vinyl* - это первая попытка использовать django как библиотеку и 
как зависимость для другого фреймворка. Я уверен, что это шанс для 
django, который без асинхронной функциональности, без сомнения, вымрет.

Лично для меня, это проект для портфолио, и я очень постараюсь, чтобы он 
взлетел.

Во-первых, в результате всех махинаций мы получаем фреймворк, который 
годится для создания смешанных WSGI+ASGI приложений, то есть, приложения с 
синхронными и асинхронными эндпоинтами (насколько такое 
распространено сейчас, и насколько удобно?)

Ещё 

Несмотря на урезанные возможности, *vinyl* всё равно предоставляет 
более широкие возможности, чем большинство чисто асинхронных фреймворков. А 
наличие собственной синхронной версии гарантирует его гармоничное развитие и 
независимость от django project.