Асинхронный django: status update

Здравствуйте, дорогие хабровчане. Некоторое время назад я писал про 
возможности добавить в django асинхронность, помимо официального подхода 
(DEP-09).

Хочу сказать, у меня получилось оформить свои идеи в нечто цельное, что 
получило название [*vinyl project*](https://github.com/pwtail/vinyl). 
Описание проекта можно прочитать на гитхабе, здесь же я хочу рассказать о 
подходе в целом и остановиться на интересных моментах.

Проект позволяет использовать django для написания нативно асинхронного кода,
соответственно, он использует асинхронный драйвер базы данных (я использовал 
[psycopg3](https://www.psycopg.org/psycopg3/)).

Проект родился после нескольких предыдущих попыток, когда я узнал, что 
django очень неплохо расширяем. Например, он поддерживает использование 
нескольких баз данных одновременно, притом что модели одни и те же. 
Соответственно, ничего не мешает считать использование асинхронного драйвера 
как другую (логически) базу данных, чем я и воспользовался.

В результате, получилось поместить всю асинхронную функциональность внутрь 
менеджера моделей. Не понадобилось делать форка django или каких-то его 
сущностей. Использовать это можно так:

```python
class Artifact(models.Model):
    ...
    vinyl = VinylManager()
```

Как делать запросы? Используя менеджер `vinyl`: `Artifact.vinyl.all()`. 
Вообще, кверисеты в django ленивые, поэтому большая часть функциональности 
заработала сама. Переопределить потребовалось не ленивые методы вроде `.get()
`, `.count()` и `aggregate`. Но с этим не возникло проблем.

Теперь другая интересная особенность: *vinyl* поддерживает одновременно 
синхронный и асинхронный режим. Это зависит от флага, который можно 
установить динамически:

`from vinyl import set_async; set_async(False)`

Данная фича является уникальной среди ORM.

Как же это делается? Самый простой способ писать такой универсальный код - 
использовать генераторы, которые бы останавливались на потенциально 
асинхронных операциях. Но это не всегда бесплатно с точки зрения 
производительности, к тому же, есть ограничения на их использование в 
асинхронном контекте (но не буду на этом останавливаться). Без генераторов 
бывает трудно обойтись, если код напрямую портируется из синхронной версии. 
Код же `vinyl` писался с нуля, там где это было нужно.

Тем не менее, код `vinyl` является универсальным, то есть одна и та же 
функция вернёт корутину или обычное значение, в зависимости от флага 
`IS_ASYNC`. Именно поэтому Вы не найдёте в коде функций с аннотацией `async`.

Вот пример такой универсальной функции:

```python
from vinyl.futures import later

def myfunc():
    result = maybe_async_func()
    
    @later
    def myfunc(result=result):
        return ...

    return myfunc()

```

В синхронном случае декоратор `later` не делает ничего, в асинхронном случае 
- выполняет корутину `result`.

В результате, `vinyl`, в sync-режиме, позволяет обычные синхронные вызовы и 
в этом очень похож на django. Это несомненное благо для документации и 
тестирование, и в будущем может избавить фреймворк от каких-нибудь 
сумасшедших фич (которые будет трудно поддержать для синхронного и 
асинхронного случая одновременно).

Нужно сказать, что и без синхронной версии *vinyl* предназначен для 
использования в django проектах, которые и так могут использовать django для 
синхронного режима. Это значит, что такие проекты могут иметь WSGI и ASGI 
эндпоинты, использующие одно окружение и базу (насколько такое 
распространено сейчас, и насколько удобно?)